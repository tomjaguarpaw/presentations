\documentclass[10pt]{beamer}

\usepackage{minted}

\title{Opaleye\\Haskell Embedded Relational Query Language}

\author{Tom Ellis}

\date{27th August 2014}

\begin{document}

\newcommand{\image}[1]{\includegraphics[scale=0.4]{#1}}

% TODO: \large{ ... contents ...} should be {\large ... contents ... }

{\Large \maketitle}



\begin{frame}[fragile]

\large{
\begin{itemize}
\item What: Haskell embedded domain specific language (EDSL)
  for generating SQL
\item Why: Want to write relational queries with all the benefits of Haskell, especially type safety and composability
\item Where: In production for over a year
\item How: Some theory; reused some internal datastructures from HaskellDB
\end{itemize}
}

\end{frame}



\begin{frame}[fragile]
\frametitle{Type safety}

\large{
Errors prevented at compile time

\begin{itemize}
\item Comparing an integer and a string

\begin{minted}{haskell}
    ...
    eq -< (quantity, personName)
    ...
\end{minted}

\item Comparing two incompatible IDs even though they are both
  integers in the database

\begin{minted}{haskell}
    ...
    eq -< (cityId, personId)
    ...
\end{minted}

\end{itemize}
}

\end{frame}


\begin{frame}[fragile]

\large{
\begin{minted}{sql}
SELECT personTable.height / personTable.age,
       departmentTable.name
FROM   departmentTable, personTable
WHERE  departmentTable.head = personTable.id
\end{minted}
}

\vspace{2em}
\center{
\image{Images/department.png}
}

\end{frame}

\begin{frame}[fragile]

\large{
\begin{minted}{sql}
SELECT addressTable.address
FROM   addressTable, personTable
WHERE  addressTable.head = personTable.id
AND    personTable.height / personTable.age < 10 
\end{minted}
}

\vspace{2em}
\center{
\image{Images/address.png}
}

\end{frame}

\begin{frame}[fragile]

\center{
\image{Images/departmentSelection.png} \\
\vspace{3em}
\image{Images/addressSelection.png} \\
\vspace{3em}
\image{Images/growthRate.png}
}

\end{frame}


\begin{frame}[fragile]

\begin{minted}{haskell}
growthRate :: Query (Wire PersonId) (Wire Double)
growthRate = proc personId -> do
    (id, height, age) <- personTable -< ()
    restrict <<< eq -< (personId, id)
    divide -< (height, age)
\end{minted}

\vspace{2em}
\center{
\image{Images/growthRate.png}
}

\end{frame}


\begin{frame}[fragile]

\begin{minted}{haskell}
departmentQuery :: Query (Wire Double, Wire String)
departmentQuery = proc () -> do
    (head, name) <- addressTable -< ()
    rate <- growthRate -< head
    returnA -< (rate, name)
\end{minted}

\vspace{2em}
\center{
\image{Images/departmentFactor.png}\\
\vspace{3em}
\image{Images/departmentSelection.png}
}

\end{frame}

\begin{frame}[fragile]
\begin{minted}{haskell}
addressQuery :: Query (Wire Address)
addressQuery = proc () -> do
    (personId, address) <- addressTable -< ()
    rate <- growthRate -< personId
    restrict <<< leqC 10 -< ratio
    returnA -< address
\end{minted}

\vspace{2em}
\center{
\image{Images/addressFactor.png}\\
\vspace{3em}
\image{Images/addressSelection.png}
}

\end{frame}


\begin{frame}
\frametitle{Summary}

\Large{
Opaleye is an approach to relational queries which is

\begin{itemize}
\item type safe
\item composable
\end{itemize}

I didn't have time to talk about

\begin{itemize}
\item aggregation is type safe and composable
\item this is why we use Arrows rather than Monads
\item both HaskellDB and Esqueleto get this wrong
\end{itemize}
}
\end{frame}

\end{document}
