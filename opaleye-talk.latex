\documentclass[10pt]{beamer}

\usepackage{minted}

\title{Opaleye}

\author{Tom Ellis}

\date{10th January 2013}

\begin{document}

\maketitle

\begin{frame}[fragile]
\frametitle{Tables of tuples}

\begin{minted}{haskell}
personTable :: Query (Wire PersonId, Wire String, Wire CityId)

runQueryDefault personTable :: [(PersonId, String, CityId)]
\end{minted}

\begin{minted}{sql}
SELECT person_id, person_name, person_city_id
FROM person_table
\end{minted}

\begin{minted}{haskell}
[ (PersonId 1, "Tom", CityId 1),
  (PersonId 2, "Simon", CityId 2),
  (PersonId 2, "Duncan", CityId 3),
  (PersonId 2, "Clemens", CityId 4) ]
\end{minted}

\end{frame}

\begin{frame}[fragile]
\frametitle{Tables of records}

\begin{minted}{haskell}
data Person a b c = Person { pId :: a,
                             pName :: b,
                             pCityId :: c }

personTable :: Query (Person (Wire PersonId)
                             (Wire String)
                             (Wire CityId))

runQueryDefault personTable :: [Person PersonId String CityId]
\end{minted}

\begin{minted}{sql}
SELECT person_id, person_name, person_city_id
FROM person_table
\end{minted}

\begin{minted}{haskell}
[Person {pId = PersonId 1, pName = "Tom", pCityId = CityId 1},
 ...]

\end{minted}

\end{frame}

\begin{frame}[fragile]
\frametitle{A query}

\begin{itemize}
\item for each person
\item look up their city
\item look up that city's country
\item return ``\emph{person name} lives in \emph{country name}''
\end{itemize}

\end{frame}
\begin{frame}[fragile]
\frametitle{A query}

\begin{minted}{haskell}
countries :: Query (Wire String)
countries = proc () -> do
    (_, personName, personCityId) <- personTable  -< ()
    (cityId, _, cityCountryId)    <- cityTable    -< ()
    (countryId, _, countryCode)   <- countryTable -< ()

    restrict <<< eq -< (personCityId, cityId)
    restrict <<< eq -< (cityCountryId, countryName)

    lives_in_string <- constant " lives in " -< ()
    cat3 -< (personName, lives_in_string, country_code)
\end{minted}

\end{frame}

\begin{frame}[fragile]
\frametitle{A query}

\begin{minted}{sql}
SELECT person_name || ' lives in ' || country_name
FROM   person_table, city_table, country_table
WHERE  person_city_id = city_id
AND    city_country_id = country_id
\end{minted}

\end{frame}

\begin{frame}[fragile]
\frametitle{Composibility}

\begin{minted}{haskell}

livesIn :: QueryArr (Wire String, Wire String) (Wire String)
livesIn = proc (personName, countryName) -> do
    lives_in_string <- constant " lives in " -< ()
    cat3 -< (personName, lives_in_string, countryName)

countryOfCity :: QueryArr (Wire CityId) (Wire CountryId)
countryOfCity = proc cityId -> do
    (cityId', _, cityCountryId)   <- countryTable -< ()
    restrict <<< eq -< (cityId, cityCountryId)
    returnA -< cityCountryId

countryNameOfCountry :: QueryArr (Wire CountryId) (Wire String)
...

countryNameOfCity :: QueryArr (Wire CityId) (Wire String)
countryNameOfCity = countryNameOfCountry <<< countryOfCity
\end{minted}

\end{frame}

\begin{frame}[fragile]
\frametitle{Composibility}

\begin{minted}{haskell}
countries :: Query (Wire String)
countries = proc () -> do
    (_, personName, personCityId) <- personTable  -< ()
    countryName <- countryNameOfCity -< personCityId
    livesIn -< (personName, countryName)
\end{minted}

\begin{minted}{haskell}
[ "Tom lives in UK",
  "Simon lives in UK",
  "Duncan lives in UK",
  "Clemens lives in NL" ]
\end{minted}

\end{frame}


\end{document}
